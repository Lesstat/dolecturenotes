# -*- org-confirm-babel-evaluate: nil; -*-
#+Title: Discrete Optimization
#+filetags: DO studium


* Network Flow
- Given a directed graph G(V,E)
- with capacity cap: E -> N_0
#+BEGIN_SRC dot :file images/graph1.jpg :exports results
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label="10"] 
          s -> b [label="5"]
          a -> b [label="15"]
          a -> t [label="5"]
          b -> t [label="10"] 
  }
#+END_SRC

#+RESULTS:
[[file:images/graph1.jpg]]

- Goal: compute a maximum flow f from $s \in V$ to $t \in V$

** Definition Flow
A flow f is function f: E -> $N_0$ such that
- $\forall e \in E: f(e) \leq c(e)$ with c as capacity
  - This is called "capacity conservation"
- $\forall v \in V \backslash \{s,t\}$:
  - $$\sum_{e=(.,v)}f(e) =  \sum_{e=(v,.)}f(e)$$
  - this is called "flow conservation"
In other words the goal is to find a flow f  which maximizes $$\sum_{e=(s,.)}f(e)$$

** Examples

#+BEGIN_SRC dot :file images/graph2.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">7</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">3</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">8</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">6</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">12</font> 10</td></tr></table>>]
  }
#+END_SRC

#+CAPTION: Network with flow. Flow in red, capacity in black
#+RESULTS:
[[file:images/graph2.jpg]]
- capacity constrained violated at:
  - (a,t) (b,t)
- flow constrained violated at:
  - node a & b (Input not equal output 7 != 14 & 11 != 12)

#+BEGIN_SRC dot :file images/graph3.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">7</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">2</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">2</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">4</font> 10</td></tr></table>>]
  }
#+END_SRC

#+RESULTS:
[[file:images/graph3.jpg]]
- valid flow value of 9 (amount that leaves s / goes into t)
- flow on (s,b) and (b,t) could be increased to achieve an even better
  flow value
- _easy_: check whether a flow value is valid or feasible
- _much harder_: check whether flow is maximum value
- But even if we could check for optimality how to compute the maximum
  flow is unclear.

** "Natural" Algorithm 
- find a path from s to t where we can send as much flow as possible.
#+BEGIN_SRC dot :file images/graph4.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label="10", color="red"] 
          s -> b [label="5"]
          a -> b [label="15", color="red"]
          a -> t [label="5"]
          b -> t [label="10", color="red"] 
  }
#+END_SRC

#+CAPTION: Network with path that can send maximum flow in red.
#+RESULTS:
[[file:images/graph4.jpg]]
- send 10 units of flow on red path
#+BEGIN_SRC dot :file images/graph5.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> b [label="5"]
          a -> b [label="5"]
          a -> t [label="5"]
  }
#+END_SRC
#+CAPTION: Remaining capacities in the network
#+RESULTS:
[[file:images/graph5.jpg]]
- It seams that no more flow can be sent from s to t since the
  remaining capacities do not allow for additional capacity/flow to be
  sent 
- But this flow of value 10 is not optimal, as we have already seen a
  flow of value 12. This can be fixed by the following idea:
  - If flow is sent on an edge, it is possible to sent flow into the
    opposite direction by reducing the sent flow.
- So algorithm works now as follows:
#+BEGIN_SRC dot :file images/graph6.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td>5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">10</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td>5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
  }
#+END_SRC
#+CAPTION: Current Flow value
#+RESULTS:
[[file:images/graph6.jpg]]
- now construct residual network:
#+BEGIN_SRC dot :file images/graph7.jpg
  digraph g{
          rankdir=LR;
          {rank=source s}
          {rank=sink t}
          {rank = same; a; b}
          a -> s [label=<<table border="0"><tr><td><font color="green">10</font></td></tr></table>>, color="green"]
          s -> b [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>, color="red"]
          a -> b [label=<<table border="0"><tr><td>5</td></tr></table>>]
          b -> a [label=<<table border="0"><tr><td><font color="green">10</font> <font color="red">5</font></td></tr></table>>, color="green", fontcolor="green" ]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>, color="red"]
          t -> b [label="10",color="green", fontcolor="green"]
  }
#+END_SRC
#+CAPTION: Residual Network: Back-edges in green. Next used path in red.
#+RESULTS:
[[file:images/graph7.jpg]]
#+BEGIN_SRC dot :file images/graph8.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">5</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
  }
#+END_SRC

#+CAPTION: Maximum flow value of 15
#+RESULTS:
[[file:images/graph8.jpg]]

** Max Flow
*** Ford Fulkerson-Algorithm
- Def:
  - For a given network $G(V,E,cap)$
  - and a valid flow $f: E -> \mathbb{N}$
  - the _residual network_ $G_f(V, E_f, cap_f)$ is defined as follows:
    - $\forall e \in E$ with $cap(e) > f(e)$ we have $e \in E_f$ with
      $cap_f(e) = cap(e) - f(e)$
    - "if there is capacity left on edge, this edge is also in $E_f$
      with remaining capacity"
    - $ \forall e=(v,w) \in E$ with $f(e) > 0$ we have  $e_R = (w,v) \in
      E_f$ with $cap_f(e_R) = f(e)$ [fn:1]
    - "if currently x unit of flow are sent form v to w, we can
      virtually send x units form w to v by not sending anything from
      v to w"
- Algorithm:
  1. start with zero flow $f(e) = 0: \forall e \in E$
  2. Construct the residual network $G_f$
  3. Find a *augmenting* path from s to t in $G_f$, send as much flow across that
     path (as determined by its bottleneck edge of minimum capacity)
     and add this flow to f.
  4. If no such path can be found return f. Otherwise goto 2
- For _integral_ capacities this algorithm eventually terminates,
  since in each round the flow increases by at least 1, but is also
  upper bounded by $$\sum_{e=(s,.)}cap(e)$$ as well as
  $$\sum_{e=(.,t)}$$[fn:2]

#+CAPTION: Example for bad choice of augmenting path. Left side shows residual network G_f, right side only the current flow
#+ATTR_LaTeX: scale=0.50
#+Label: fig:ff_bad_example
[[file:images/Fig_02_edited.jpg]]
- Why choosing the right path is important is illustrated by figure
  ref:fig:ff_bad_example 
- this continues until there is no path from s to t in G_f in this
  example the unclever choice of the augmenting path leads to a 1998
  augmentations.
- more generally to a algorithm with running time $O(val(f_{opt}) * (m+n))$
- $f_{opt}$ : value of maximum flow
- $(m+n)$: Depth-first-search or Breadth-first-search[fn:3]
- not polynomial because $val(f_{opt}$) is not polynomial (depends on
  encoding of the problem)

**** Is the algorithm correct?
- simple:
#+CAPTION: Prove for optimality by making a cut
#+LABEL: fig:ff_optimality
[[file:images/Fig_03_edited.jpg]]
- Figure ref:fig:ff_optimality shows a cut that can be used to proof
  optimality of the flow. [fn:4]
- partition of the nodeset into 2 groups which separate s and t.
- to sent flow from s to t the flow has to cross the boundary between
  the partition
- all the crossing edges have maximum flow
- Their summed capacity is 120 which is an upper bound for the flow
- Any (such?) cut implies a upper bound for the flow
- the value of the max flow = MinCut
- Definition:
  - Let G(V,E) be a directed graph, $\emptyset \neq A \not\subseteq V$. 
  - the _directed cut_ induced by A is $dcut(A):= \{e=(v,w) | v\in A,
    w \notin A\}$ that is, the set of edges having their source in A
    and their target in V\A
- Lemma:
  - For a directed graph G(V,E) with capacities $cap: E -> \mathbb{N}$, let $A
    \subseteq V$  with $s \in A, t \in V \backslash A$
  - Then $$\sum_{e \in dcut(A)} cap(e)$$ is an upper bound on the
    maximum flow value from s to t.
- Pf:
  - Consider any (maximum) flow form s to t. Each unit of flow has to
    cross the boundary form A to V\A at least once.
  - But in total at most $$\sum_{e \in dcut(A)} cap(e)$$ units of flow
    can cross the boundary.
- High-level ideal of correctness Proof from Ford-Fulkerson: look at
  last residual network and use this to derive a directed cut of value
  = current flow
- In detail:
  - Let us take as A the set of nodes reachable from s in the last
    residual network before termination
  - Note. $t \notin A$ since we terminated.
- Lemma:
  - Let f be the flow produced by FF for a network G(V,E,cap) and let
    e=(v,w) be such that $|\{v,w\} \cap A| = 1$ (e is out of or into A)
  - Then the following holds
    - if $v \in A$ (e is outgoing of A) then f(e) = cap(e)
    - if $v \notin A$ (e is incoming into A) the f(e) = 0

#+CAPTION: Cut A which includes all nodes reachable from s
#+LABEL: fig:ff_cut
    [[file:images/Fig_04_edited.jpg]] 
- Proof:
  - $v \in A, w \notin A, e=(v,w)$ if f(e) < cap(e) then the edge
    (v,w) is still present in G_f
  - => if $v \in A$ the also $w \in A$ -> contradiction
  - $v \notin A, w \in A, e=(v,w)$ if f(e) > 0 then the edge $(w,v) \in G_f$
  - =>  $v \in A$ -> contradiction
  - qed
- This immediately implies correctness of FF as the flow computed by
  FF has value $$\sum_{e=(v, w), v \in A, w \notin A} f(e) =
  \sum_{e=(v, w), v \in A, w \notin A} cap(e)$$
- second sum is the upper bound for flow by the set A [fn:5]

**** Capacity scaling
- Idea
  - First look only for augmenting paths with somehow "large"
    bottleneck capacity, only if no such paths exist, look for smaller
    bottleneck capacities
  - start with zero flow f=0
  - D = next smaller power of 2 of the max. capacity = $2^{\lfloor
    log_2(cap_{max}) \rfloor}$
  - ~while~ $D \geq 1$ ~do~
    - $G_f^D$ <- residual network of G wrf f, restricted to edges of
      capacity $\geq D$, 
    - ~while~ $\exists$  an augmenting path in $G_f^D$ ~do~
      - augment f
      - recompute $G_f^D$
    - ~od~
    - D = D/ 2
  - ~od~
  - ~return~ f
- Obviously, algorithm is correct since at some point D = 1 and this
  is plain FF.
- Lemma:
  - Let $f_D$ be the flow after completing augmentations with bound
    D. Then the value of max flow is bounded by the $val(f_D) + m * D$
- Proof: -> *wrong Proof -> Compare to scribe notes*
  - Consider the residual network $G_f^D$ after the last augmentation
    for value D. and let A be the set of nodes from s in $G_f^D$
  - Then consider the original network G, the flow $f_D$ and the set
    A. All edges leaving A with $cap \geq D$ are fully saturated and
    yield a flow of value $val(f_D)$. There are at mots m edges of
    capacity < D leaving A.
  - => one can send at most m*D across the boundary from A to V\A additionally.
  - qed
- When Algorithm reaches the end of the outer loop, the Lemma tells us that the
flow can grow by at most m*d in _all_ future iterations of the outer
loop. 
- But in the next round (with value D/2) in each successful iteration of the
inner loop, the flow grow by at least D/2.
- => The iteration of the outer loop ca have at most $\frac{ m*D}{D/2} = 2m$
- Theorem: FF with capacity scaling has running time of
  $O((log(cap_{max}))*m*(m+n)) = O(m^2 log(cap_{max}))$ 
  - $log(cap_{max})$: # iterations of outer loop
  - m : # iterations of inner loop
  - (m+n): cost for single augmentation
    - Normal FF $O(( m+n )*cap_{max}) = O(m^2 cap_{max})$ -> much slower

**** Successive Shortest Path (Edmonds-Karp-Algorithm)
- Consider the variant of FF where we always choose a shortest (wrt #
  edges) path from s to t, that is, the standard variant with BFS to
  determine the augmenting path.
- Lemma 6:
  - during the course of the algorithm, the length of the augmenting
    paths never decreases.
- Lemma 7:
  - After at most O(m) augmentations, the length of the augmenting
    path increases by at least 1.
- Theorem:
  - FF with shortest path augmenations terminates after $O(m^2 *n)$ steps.
- Proof:
  - The first augmenting path has length at least 1. After O(m)
    augmentations it has length at least 2, ... the augmenting path
    can have length at most n 
  - => O(n*m) augmentations, each of which cost O(m+n)
- Proof(Lemma 6):
  - Let l(v) be the hop distance of v from s in the residual network,
    G_l the subgraph of the residual network which only contains edges
    (u,v) with l(v) = l(u)+1
  - When augmenting augmenting along path \pi, two things can happen
    along this path:
    - (a) edges in the residual network disappear (as their capacity
      is fully used up)[fn:6] 
    - (b) back/ virtual edges are created that have not been present
      before.[fn:7]
  - None of these operations can decrease the level of a node.
  - => Distance to any node in particular t never decreases
- Proof(Lemma 7)
  - Le E_k be the set of edges at the beginning of a phase[fn:8] when the
    distance between s and t is k.
  - As soon as the shortest path  from s to t uses an edge not in E_k,
    it has length > k. Since in every augmentation step at least on
    edge (the bottleneck edges) is eliminated[fn:9] from E_k, after at
    most m steps the length of the shortest path from s to t is increased.

** MinCostFlow (Better MinCostMaxFlow Problem)
- Figure 1
- Every node can either be a source or a sink
- Example
  - Figure 2
  - is a valid flow as:
    - on every edge we do not exceed the capacity constraint
      - $\forall e \in G: f(e) \leq cap(e)$
    - Flow conservation are satisfied:
      - $$\forall v \in G: \sum_{e=(v,.)}f(e) = \sum_{e=(.,v)}f(e) +b(v)$$
      - b(v) demand/supply of node v ( flow entering or leaving at node v )
  - This flow has cost of:
    - $$\sum_{e \in E}f(e)*cost(e)$$
    - $=f(ab)*cost(ab)+ f(ac)*cost(ac)+f(bc)*cost(bc)+f(bd)*cost(bd)+f(cd)*cost(cd)$
    - $= 2*2 + 2*2 + 1 *10 + 2*3 + 0*1 = 24$
*** Formal Problem Definition
Given a directed network G(V,E) witch capacities $cap: E \rightarrow
\mathbb{N}$ and $cost:E \rightarrow \mathbb{Z}$ and a function $b:V
\rightarrow \mathbb{Z}$ which determines whether a node v has a
surplus/ supply of flow (b(v)>0) or a demand of flow (b(v)<0) with
- $$\sum_{v:b(v)>0}b(v) = - \sum_{v:b(v)<0} b(v)$$
- we want to find a flow $f: E \rightarrow \mathbb{N}$ such that
  - $\forall e \in E:  o \leq f(e) \leq cap(e)$ "capacity constraint"
  - $$\forall v \in V: b(v) + \sum_{e=(w,v)}f(e) = \sum_{e=(v,w)}f(e)$$
    "flow conservation constraint"
  - and minimizing $$\sum_{e\in E}f(e)*cost(e)$$
*** High level Algorithm idea:
1. Find some feasible flow (-> exercise) (not caring about cost)
2. Optimize cost of the flow
*** ad 2. Idea
- "Reroute" flow as long this reduces the costs without violating constraints
- One possibility to reroute flow without violating flow conservation
  constraints is sending flow in a cycle.
  - the flow for Nodes not in the cycle doesn't change
  - the flow for Nodes on the cylce they gain as much as they loose
- If sending flow along a cycle decreases total cost we should do so.
- As in maxflow we consider the residual network $G_f(V,E_f)$ for a
  given network G(V,E) and flow f.
- For each edge $e \in E$ we construct up to two edges in $E_f$ as follows:
  - if f(e) < cap(e) then there is an edge $e' = (v,w) \in E_f$ with
    - cost $cost(e')= cost(e)$ and
    - $cap(e') = cap(e) - f(e)$
  - if f(e)>0 then there is a virtual edge $e'' =(v,w)\in E_f$ with
    - $cap(e'') = f(e)$ and
    - $cost(e'') = - cost(e)$
- Example
  - *Exersice* use cycle acdba instead and cont cycle cancelling until termination
  - Figure 3
  - There is a negative cycle acba of cost -10.
  - For every unit of flow sent across that cycle the total cost
    decreases by 10
  - We can send up to 1 unit of flow around (due to bottleneck edge ac)
  - resulting flow and residual network, which contains no negative cycle
  - Figure 4
  - Alg. finishes  [fn:10]
- Algorithm is also called "cycle cancelling" algorithm as once flow
  is sent across negative cycle, it will not be present in the next
  residual network anymore.
- Clearly, algorithm terminates as cost decreases by at least 1 per
  cycle cancelling.
*** Proof
- Lemma
  - Let f be a valid flow in G, $G_f$ the respective residual network.
  - Then, f is a minCost flow if and only if $G_f$ does not contain a
    negative cylce.
- Proof:
  - The ''=>'' is trivial
  - ''<='' assume $G_f$ does not contain a negative cylce but f is not a
    minCost flow. We will derive a contradiction hence proofing the Lemma.
  - Let $f^*$ be a minCost flow and consider the flow-difference f' =
    $f^* - f$
  - we claim f' has to contain a negative cycle
  - Clearly, cost(f')< 0 since $cost(f^*)< cost(f)$
  - Furthermore f' must satisfy flow conservation (inflow = outflow),
    that is at any v, the outflow of f' must equal the inflow of f'.
  - Figure 5
  - Hence f' can be decomposed into a set of cycles
  - Figure 6
  - Since the total cost of the cycles is negative, one of the cycles
    must have negative cost.
  - This cycle is also a negative cost cycle in $G_f$
  - this is a contradiction
*** Problem to solve
- Given a directed weighted graph G(V,E,c) with edge costs $c : E
  \rightarrow \mathbb{Z}$ find a negative cycle.
- Idea to find negative cycles:
  - Create n+1 copies of the V
  - Figure 1
  - Connect node v in layer (i) with node w in layer (i+1) iff [fn:11]
    $(v,w) \in E$ (same costs)
  - Then $\forall v_i$ compute shortest path distances from $v_i^{(1)}$
    to all other nodes in this layered graph.
  - if there exists a node $v_i^{(j)}, j > 1$ with distance <0, we have
    found a negative cycle starting in $v_i$
- Running Time:
  - Computing shortest path distances from $v_1^{(1)}$ costs O(n*m)
  - => in total we can find a negative cycle $O(n^2m)$
- Finding the "most negative" cycle (which seems desirable to decrease
  cost as much as possible) is NP-hard unfortunately, reduction via
  Hamilton Cycle Problem [fn:12].
*** Possible Running Time Improvements
- Finding the cycle C minimizing $\frac{cost(c)}{|C|}$, that is the
  min mean cost cycle (in fact using the same algorithm).
- If always the min mean cost cycle is cancelled, one can guarantee
  polynomial running time of the cycle cancelling algorithm. (no
  details here/ not part of the exam)
*** Application of min-Cost-Flow
- Consider a set of jobs J and a set of workers W.
- Each worker $w \in W$ has the qualification to perform jobs $J_w
  \subseteq J$
- Question
  - Is there an assignment of jobs to workers such that 
  - every job is done
  - no worker performs more than one job
  - no worker performs a job he is not qualified for
  - Figure 2
- Extension with costs
  - worker w performing job j incurs cost of c(w,j)
  - Goal: Find assignment of jobs to works minimizing total cost.
  - add costs c(w,j) to edge e=(w,j). Use min-Cost-Flow
- Heiratssatz (not relevant for Exam)
  - Figure 3
  - Q: Is there an assignment of men to women such that everyone is
    married (without fighting)
  - Hall's Theorem:
    - Assignment possible if and only if $\forall S \subseteq M: |
      N(S)| \geq |S|$ [fn:13]
**** Airplane hopping
- Consider a small airline with only one plane serving n-1 cities in a
  round trip every day.
- The airline makes money by picking up passengers at $v_i$ and dropping
  them off at $v_j$
- Unfortunately the plane is not big enough to transport all passengers.
- Assume there are
  - $t_{ij}$ passengers who want to go from $v_i$ to $v_j$ willing to pay a
    fare of
  - $f_{ij}$ for that
  - the plane has p seats.
- which passengers should be picked up to maximize the revenue?
- Figure 4
- e.g:
  - 2 from $v_1$ -> $v_3$ => 6 €
  - +    1 for $v_2$ -> $v_4$ => 4 €
  - sums to 10 €
  - OR
  - 3 from $v_2$ -> $v_4$ => 12€
- Modelling as MinCostFlow Problem
- Figure 5
- Nodes i,j represents passengers who want to go from i to j. [fn:14]
*** Alternative Approach to MinCostFlow (via successive shortest path)
- Recall the Cycle Cancelling Flow Approach
  1. Find some feasible flwo (e.g. FF)
  2. "Kill" negatvice cost cycles from residual networks as long as possible
- Always maintain feasibility, steer the solution towards optimality
- Now
  - Try to always keep a cost optimal solution (for part of the
    problem), but iteratively cover more and more of the problem until
    feasibility is reached [fn:15].
  - We can compute the minCostFlow also via a simple variation of
    Ford-Fulkersion (!)
  - where in each round we choose as augmenting path the cheapest path
    in the residual network connecting a supply node with a demand node.
  - Figure 7
  - Such a path can be found via a shortest path computation on a
    slightly enhanced residual network (see picture above)
  - Bellman-Ford can be used for that
  - Eventually the flow will become feasible[fn:16] (and cost-optimal).
- Proof-Idea: (for optimality)
  - Show that all residual networks occuring throughout the course of
    the algorithm have no negative cycles.
  - The first residual network obviously has no neg. cycles
  - Now consider the residual network after first augmentation and
    assume it contains a negative cycle C.
  - Decompose C into $C_1$ and $C_2$ where $C_1$ starts and ends with
    negative cost edges and $C_2$ only contains edges with
    non-negative costs
  - Figure 8 Red edges have negative cost
  - $cost(C_1)$ < 0 and $|cost(C_1)|$ > $cost(C_2)$
  - For simplification assume that C_1 consists solely of negative
    cost edges which also form a continuous reverse subpath of the first
    augmenting path.
  - Note that $C_2$ yields a path from $v_2$ to $v_1$ of $cost(C_2)$
    < $|cost(C_1)|$
  - contradiction to choice of augmenting paths as always cost-minimal
    path
- Now we know that the 1st (trivial) and 2nd residual networks contain
  no negative cycles we can extend this to every following residual
  network by applying the Johnson Shifting Theorem (1975)
- Theorem
  - Let G(V,E,c) be a directed weighted graph with possibly negative
    edge costs but without negative cycles. Then there exists a
    potential function $\phi V -> \mathbb{Z}$ such that the shifted
    edge consts:
    - $c'(v,w) = c(v,w) + \phi(v)  \phi(w)$
    - are all non-negative and shortest paths in G(V,E,c) remain
      shortest in G(V,E,c') and vice versa.
- Proof: 
  - w.l.o.g assume $\exists s \in V$ from which all other node
    can be reached. 
  - Since G(V,E,c) is free of negative cycles, shortest
      patht distances are well-defined and can be computed using
      Bellman-Ford in O(mn) time.
  - Then define $\phi(v) = d_s(v)$.
  - First observe that due to d_s() being shortest path distances we
    have
  - Figure 9
  - $d_s(w) \leq d_s(v) + c(v,w)$ for every edge (v,w)
  - => $c'(v,w) = c(v,w) + \phi(v) - \phi(w)$
  - $= c(v,w) + d_s(v) - d_s(w)$
  - $\geq 0$
  - $c(v,w) \geq d_s(w) - d_s(v)$
  - => all new edge costs are non-negative
  - now consider some path $\pi = sv_0v_1...t$ in G(V,E,c'). The cost
    of $\pi$ is:
    - $$\sum_{(v,w) \in \pi}c'(v,w) = \sum_{(v,w) \in \pi} c(v,w) +
      \phi(v) - \phi(w)$$
    - $$= (\sum_{(v,w) \in \pi} c(v,w)) + \phi(s) - \phi(t)$$
    - So the cost of a path $\pi$ from s to t in G(V,E,c') is the cost
      in G(V,E,c) plus the potential of the source minus the potential
      of the target.
    - Since the latter two are invariant for different st-paths,
      shortest paths in G(V,E,c) are shortest paths in G(V,E,c') and
      vice versa.
    - qed.
- So we can apply this Johnson Theorem to 2nd residual network and
  argue again as before.

* Linear Programming
- Example in \mathbb{R}^2
  - LP is equivalent to "looking for the 'best' point satisfying some constraint"
  - Figure 10
* Exercises

** Sheet 1

*** Problem 2
- case 1: There is an s-t path with infinite capacity
  - flow from s to t is unbounded ( $\infty$ )
- case 2: There is no s-t path with inf. capacity
  - there is an s-t-cut where all outgoing edges have finite capacity
  - FF increases total flow by at least 1 in each iteration
  - Max flow is upper bounded by a finite number
  - => Ford Fulkerson will terminate in this case

*** Problem 3
- a): Capacity and flow conservation are fulfilled, so the flow is
  valid 
- b): all edges going into t are saturated. So the flow is optimal.
  - more formal:
  - the capacity of edges in $dcut(\{s,a,b,c,d,e,f\})$ gives an upper
    bound to total flow in the network as $s \in A, t \notin A$
  - The flow matches the upper bound => optimality

*** Problem 4
- a):
  - Construct a network with s as source and t as sink
  - add a node for each student
  - add an edge from s to each student with capacity 1
  - add a node for each traineeship
  - add an edge from each traineeship to t with capacity 1
  - add edges from each student to the traineeship he/she prefers with
    capacity 1
  - If the maximum flow equals n (number of students) the preferences
    can be fulfilled.
  - a backedge from a traineeship to a student in the last residual
    network implies that the student gets the traineeship.
  - more formal:
    - set of students S $|S| = n$
    - set of traineeships T $|T| = m$
    - $ m \geq n$
    - Figure 1
    - $cap(e) = 1 \forall e \in E$
    - if max flow = n $\rightarrow$ there is a valid assignment of
      students to traineeships
    - if $max flow < n$ $\rightarrow$ there is no such assignment
    - How to get a valid assignment:
      - $\forall e=(v,u), v \in S, u \in T$ if f(e) = 1
      - student v is assigned to traineeship u
- b):
  - Figure 2
  - Given directed G(V,E)
  - construct G'(V',E')
  - $\forall v \in V\backslash\{s,t\}$ introduce $v',v'' \in V'$
    $(v',v'') \in E'$
  - rename s to s'' and t to t' in G'
  - $\forall e=(v,u) \in E$ introduce $(v'',u') \in E'$
  - assign cap=1 to every Edge
  - maximum flow from s to t in G' yields the number of node-disjoint paths in G
  - Figure 3


* Footnotes

[fn:16] Obvious, since it is like computing first feasible flow for
cycle cancelling

[fn:15] Approach will never violate the capacity constraints. But it
will not always use all the supplies and all the demands.

[fn:14] There could be a modelling exercise in the exam

[fn:13] There is a connection to the set A in the proof of Ford
Fulkerson. (A plays the roll of S)


[fn:12] Given a graph G(V,E), does there exist a simple cycle
containing all nodes.

[fn:11] if and only if

[fn:10] In Exam probably at least one question where MaxFlow or
MinCostFlow is computed step by step by hand

[fn:9] used to its full capacity

[fn:8] Sequence of states/augmentations

[fn:7] Connections are made from higher level to lower level. So
shortest path is not decreased.

[fn:6] by removing edges from a network, the distance cannot be decreased.

[fn:5] correctness proof of FF is common Exam question. 

[fn:4] In Exam sometimes: Why is it optimal what you have computed?
The answer is not that in the residual network there is no path from s
to t. 

[fn:3] |E| = m & |V| = n

[fn:2] typical exam question: Why does Ford Fulkerson terminate?

[fn:1] e_R = Reverse edge 

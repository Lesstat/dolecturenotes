# -*- org-confirm-babel-evaluate: nil; -*-
#+Title: Discrete Optimization
#+filetags: DO studium


* Network Flow
- Given a directed graph G(V,E)
- with capacity cap: E -> N_0
#+BEGIN_SRC dot :file images/graph1.jpg :exports results
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label="10"] 
          s -> b [label="5"]
          a -> b [label="15"]
          a -> t [label="5"]
          b -> t [label="10"] 
  }
#+END_SRC

#+RESULTS:
[[file:images/graph1.jpg]]

- Goal: compute a maximum flow f from $s \in V$ to $t \in V$

** Definition Flow
A flow f is function f: E -> $N_0$ such that
- $\forall e \in E: f(e) \leq c(e)$ with c as capacity
  - This is called "capacity conservation"
- $\forall v \in V \backslash \{s,t\}$:
  - $$\sum_{e=(.,v)}f(e) =  \sum_{e=(v,.)}f(e)$$
  - this is called "flow conservation"
In other words the goal is to find a flow f  which maximizes $$\sum_{e=(s,.)}f(e)$$

** Examples

#+BEGIN_SRC dot :file images/graph2.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">7</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">3</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">8</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">6</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">12</font> 10</td></tr></table>>]
  }
#+END_SRC

#+CAPTION: Network with flow. Flow in red, capacity in black
#+RESULTS:
[[file:images/graph2.jpg]]
- capacity constrained violated at:
  - (a,t) (b,t)
- flow constrained violated at:
  - node a & b (Input not equal output 7 != 14 & 11 != 12)

#+BEGIN_SRC dot :file images/graph3.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">7</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">2</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">2</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">4</font> 10</td></tr></table>>]
  }
#+END_SRC

#+RESULTS:
[[file:images/graph3.jpg]]
- valid flow value of 9 (amount that leaves s / goes into t)
- flow on (s,b) and (b,t) could be increased to achieve an even better
  flow value
- _easy_: check whether a flow value is valid or feasible
- _much harder_: check whether flow is maximum value
- But even if we could check for optimality how to compute the maximum
  flow is unclear.

** "Natural" Algorithm 
- find a path from s to t where we can send as much flow as possible.
#+BEGIN_SRC dot :file images/graph4.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label="10", color="red"] 
          s -> b [label="5"]
          a -> b [label="15", color="red"]
          a -> t [label="5"]
          b -> t [label="10", color="red"] 
  }
#+END_SRC

#+CAPTION: Network with path that can send maximum flow in red.
#+RESULTS:
[[file:images/graph4.jpg]]
- send 10 units of flow on red path
#+BEGIN_SRC dot :file images/graph5.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> b [label="5"]
          a -> b [label="5"]
          a -> t [label="5"]
  }
#+END_SRC
#+CAPTION: Remaining capacities in the network
#+RESULTS:
[[file:images/graph5.jpg]]
- It seams that no more flow can be sent from s to t since the
  remaining capacities do not allow for additional capacity/flow to be
  sent 
- But this flow of value 10 is not optimal, as we have already seen a
  flow of value 12. This can be fixed by the following idea:
  - If flow is sent on an edge, it is possible to sent flow into the
    opposite direction by reducing the sent flow.
- So algorithm works now as follows:
#+BEGIN_SRC dot :file images/graph6.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td>5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">10</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td>5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
  }
#+END_SRC
#+CAPTION: Current Flow value
#+RESULTS:
[[file:images/graph6.jpg]]
- now construct residual network:
#+BEGIN_SRC dot :file images/graph7.jpg
  digraph g{
          rankdir=LR;
          {rank=source s}
          {rank=sink t}
          {rank = same; a; b}
          a -> s [label=<<table border="0"><tr><td><font color="green">10</font></td></tr></table>>, color="green"]
          s -> b [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>, color="red"]
          a -> b [label=<<table border="0"><tr><td>5</td></tr></table>>]
          b -> a [label=<<table border="0"><tr><td><font color="green">10</font> <font color="red">5</font></td></tr></table>>, color="green", fontcolor="green" ]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>, color="red"]
          t -> b [label="10",color="green", fontcolor="green"]
  }
#+END_SRC
#+CAPTION: Residual Network: Back-edges in green. Next used path in red.
#+RESULTS:
[[file:images/graph7.jpg]]
#+BEGIN_SRC dot :file images/graph8.jpg
  digraph g{
          rankdir=LR;
          {rank = same; a; b}
          s -> a [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
          s -> b [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          a -> b [label=<<table border="0"><tr><td><font color="red">5</font> 15</td></tr></table>>]
          a -> t [label=<<table border="0"><tr><td><font color="red">5</font> 5</td></tr></table>>]
          b -> t [label=<<table border="0"><tr><td><font color="red">10</font> 10</td></tr></table>>]
  }
#+END_SRC

#+CAPTION: Maximum flow value of 15
#+RESULTS:
[[file:images/graph8.jpg]]

** Max Flow
*** Ford Fulkerson-Algorithm
- Def:
  - For a given network $G(V,E,cap)$
  - and a valid flow $f: E -> \mathbb{N}$
  - the _residual network_ $G_f(V, E_f, cap_f)$ is defined as follows:
    - $\forall e \in E$ with $cap(e) > f(e)$ we have $e \in E_f$ with
      $cap_f(e) = cap(e) - f(e)$
    - "if there is capacity left on edge, this edge is also in $E_f$
      with remaining capacity"
    - $ \forall e=(v,w) \in E$ with $f(e) > 0$ we have  $e_R = (w,v) \in
      E_f$ with $cap_f(e_R) = f(e)$ [fn:1]
    - "if currently x unit of flow are sent form v to w, we can
      virtually send x units form w to v by not sending anything from
      v to w"
- Algorithm:
  1. start with zero flow $f(e) = 0: \forall e \in E$
  2. Construct the residual network $G_f$
  3. Find a *augmenting* path from s to t in $G_f$, send as much flow across that
     path (as determined by its bottleneck edge of minimum capacity)
     and add this flow to f.
  4. If no such path can be found return f. Otherwise goto 2
- For _integral_ capacities this algorithm eventually terminates,
  since in each round the flow increases by at least 1, but is also
  upper bounded by $$\sum_{e=(s,.)}cap(e)$$ as well as
  $$\sum_{e=(.,t)}$$[fn:2]

#+CAPTION: Example for bad choice of augmenting path. Left side shows residual network G_f, right side only the current flow
#+ATTR_LaTeX: scale=0.50
#+Label: fig:ff_bad_example
[[file:images/Fig_02_edited.jpg]]
- Why choosing the right path is important is illustrated by figure
  ref:fig:ff_bad_example 
- this continues until there is no path from s to t in G_f in this
  example the unclever choice of the augmenting path leads to a 1998
  augmentations.
- more generally to a algorithm with running time $O(val(f_{opt}) * (m+n))$
- $f_{opt}$ : value of maximum flow
- $(m+n)$: Depth-first-search or Breadth-first-search[fn:3]
- not polynomial because $val(f_{opt}$) is not polynomial (depends on
  encoding of the problem)

**** Is the algorithm correct?
- simple:
#+CAPTION: Prove for optimality by making a cut
#+LABEL: fig:ff_optimality
[[file:images/Fig_03_edited.jpg]]
- Figure ref:fig:ff_optimality shows a cut that can be used to proof
  optimality of the flow. [fn:4]
- partition of the nodeset into 2 groups which separate s and t.
- to sent flow from s to t the flow has to cross the boundary between
  the partition
- all the crossing edges have maximum flow
- Their summed capacity is 120 which is an upper bound for the flow
- Any (such?) cut implies a upper bound for the flow
- the value of the max flow = MinCut
- Definition:
  - Let G(V,E) be a directed graph, $\emptyset \neq A \not\subseteq V$. 
  - the _directed cut_ induced by A is $dcut(A):= \{e=(v,w) | v\in A,
    w \notin A\}$ that is, the set of edges having their source in A
    and their target in V\A
- Lemma:
  - For a directed graph G(V,E) with capacities $cap: E -> \mathbb{N}$, let $A
    \subseteq V$  with $s \in A, t \in V \backslash A$
  - Then $$\sum_{e \in dcut(A)} cap(e)$$ is an upper bound on the
    maximum flow value from s to t.
- Pf:
  - Consider any (maximum) flow form s to t. Each unit of flow has to
    cross the boundary form A to V\A at least once.
  - But in total at most $$\sum_{e \in dcut(A)} cap(e)$$ units of flow
    can cross the boundary.
- High-level ideal of correctness Proof from Ford-Fulkerson: look at
  last residual network and use this to derive a directed cut of value
  = current flow
- In detail:
  - Let us take as A the set of nodes reachable from s in the last
    residual network before termination
  - Note. $t \notin A$ since we terminated.
- Lemma:
  - Let f be the flow produced by FF for a network G(V,E,cap) and let
    e=(v,w) be such that $|\{v,w\} \cap A| = 1$ (e is out of or into A)
  - Then the following holds
    - if $v \in A$ (e is outgoing of A) then f(e) = cap(e)
    - if $v \notin A$ (e is incoming into A) the f(e) = 0

#+CAPTION: Cut A which includes all nodes reachable from s
#+LABEL: fig:ff_cut
    [[file:images/Fig_04_edited.jpg]] 
- Proof:
  - $v \in A, w \notin A, e=(v,w)$ if f(e) < cap(e) then the edge
    (v,w) is still present in G_f
  - => if $v \in A$ the also $w \in A$ -> contradiction
  - $v \notin A, w \in A, e=(v,w)$ if f(e) > 0 then the edge $(w,v) \in G_f$
  - =>  $v \in A$ -> contradiction
  - qed
- This immediately implies correctness of FF as the flow computed by
  FF has value $$\sum_{e=(v, w), v \in A, w \notin A} f(e) =
  \sum_{e=(v, w), v \in A, w \notin A} cap(e)$$
- second sum is the upper bound for flow by the set A [fn:5]

**** Capacity scaling
- Idea
  - First look only for augmenting paths with somehow "large"
    bottleneck capacity, only if no such paths exist, look for smaller
    bottleneck capacities
  - start with zero flow f=0
  - D = next smaller power of 2 of the max. capacity = $2^{\lfloor
    log_2(cap_{max}) \rfloor}$
  - ~while~ $D \geq 1$ ~do~
    - $G_f^D$ <- residual network of G wrf f, restricted to edges of
      capacity $\geq D$, 
    - ~while~ $\exists$  an augmenting path in $G_f^D$ ~do~
      - augment f
      - recompute $G_f^D$
    - ~od~
    - D = D/ 2
  - ~od~
  - ~return~ f
- Obviously, algorithm is correct since at some point D = 1 and this
  is plain FF.
- Lemma:
  - Let $f_D$ be the flow after completing augmentations with bound
    D. Then the value of max flow is bounded by the $val(f_D) + m * D$
- Proof:
  - Consider the residual network $G_f^D$ after the last augmentation
    for value D. and let A be the set of nodes from s in $G_f^D$
  - Then consider the original network G, the flow $f_D$ and the set
    A. All edges leaving A with $cap \geq D$ are fully saturated and
    yield a flow of value $val(f_D)$. There are at mots m edges of
    capacity < D leaving A.
  - => one can send at most m*D across the boundary from A to V\A additionally.
  - qed
- When Algorithm reaches the end of the outer loop, the Lemma tells us that the
flow can grow by at most m*d in _all_ future iterations of the outer
loop. 
- But in the next round (with value D/2) in each successful iteration of the
inner loop, the flow grow by at least D/2.
- => The iteration of the outer loop ca have at most $\frac{ m*D}{D/2} = 2m$
- Theorem: FF with capacity scaling has running time of
  $O((log(cap_{max}))*m*(m+n)) = O(m^2 log(cap_{max}))$ 
  - $log(cap_{max})$: # iterations of outer loop
  - m : # iterations of inner loop
  - (m+n): cost for single augmentation
    - Normal FF $O(( m+n )*cap_{max}) = O(m^2 cap_{max})$ -> much slower

**** Successive Shortest Path (Edmonds-Karp-Algorithm)
- Consider the variant of FF where we always choose a shortest (wrt #
  edges) path from s to t, that is, the standard variant with BFS to
  determine the augmenting path.
- Lemma 6:
  - during the course of the algorithm, the length of the augmenting
    paths never decreases.
- Lemma 7:
  - After at most O(m) augmentations, the length of the augmenting
    path increases by at least 1.
- Theorem:
  - FF with shortest path augmenations terminates after $O(m^2 *n)$ steps.
- Proof:
  - The first augmenting path has length at least 1. After O(m)
    augmentations it has length at least 2, ... the augmenting path
    can have length at most n 
  - => O(n*m) augmentations, each of which cost O(m+n)
- Proof(Lemma 6):
  - Let l(v) be the hop distance of v from s in the residual network,
    G_l the subgraph of the residual network which only contains edges
    (u,v) with l(v) = l(u)+1
  - When augmenting augmenting along path \pi, two things can happen
    along this path:
    - (a) edges in the residual network disappear (as their capacity
      is fully used up)[fn:6] 
    - (b) back/ virtual edges are created that have not been present
      before.[fn:7]
  - None of these operations can decrease the level of a node.
  - => Distance to any node in particular t never decreases
- Proof(Lemma 7)
  - Le E_k be the set of edges at the beginning of a phase[fn:8] when the
    distance between s and t is k.
  - As soon as the shortest path  from s to t uses an edge not in E_k,
    it has length > k. Since in every augmentation step at least on
    edge (the bottleneck edges) is eliminated[fn:9] from E_k, after at
    most m steps the length of the shortest path from s to t is increased.

* Exercises

** Sheet 1

*** Problem 2
- case 1: There is an s-t path with infinite capacity
  - flow from s to t is unbounded ( $\infty$ )
- case 2: There is no s-t path with inf. capacity
  - there is an s-t-cut where all outgoing edges have finite capacity
  - FF increases total flow by at least 1 in each iteration
  - Max flow is upper bounded by a finite number
  - => Ford Fulkerson will terminate in this case

*** Problem 3
- a): Capacity and flow conservation are fulfilled, so the flow is
  valid 
- b): all edges going into t are saturated. So the flow is optimal.
  - more formal:
  - the capacity of edges in $dcut(\{s,a,b,c,d,e,f\})$ gives an upper
    bound to total flow in the network as $s \in A, t \notin A$
  - The flow matches the upper bound => optimality

*** Problem 4
- a):
  - Construct a network with s as source and t as sink
  - add a node for each student
  - add an edge from s to each student with capacity 1
  - add a node for each traineeship
  - add an edge from each traineeship to t with capacity 1
  - add edges from each student to the traineeship he/she prefers with
    capacity 1
  - If the maximum flow equals n (number of students) the preferences
    can be fulfilled.
  - a backedge from a traineeship to a student in the last residual
    network implies that the student gets the traineeship.
  - more formal:
    - set of students S $|S| = n$
    - set of traineeships T $|T| = m$
    - $ m \geq n$
    - Figure 1
    - $cap(e) = 1 \forall e \in E$
    - if max flow = n $\rightarrow$ there is a valid assignment of
      students to traineeships
    - if $max flow < n$ $\rightarrow$ there is no such assignment
    - How to get a valid assignment:
      - $\forall e=(v,u), v \in S, u \in T$ if f(e) = 1
      - student v is assigned to traineeship u
- b):
  - Figure 2
  - Given directed G(V,E)
  - construct G'(V',E')
  - $\forall v \in V\backslash\{s,t\}$ introduce $v',v'' \in V'$
    $(v',v'') \in E'$
  - rename s to s'' and t to t' in G'
  - $\forall e=(v,u) \in E$ introduce $(v'',u') \in E'$
  - assign cap=1 to every Edge
  - maximum flow from s to t in G' yields the number of node-disjoint paths in G
  - Figure 3


* Footnotes

[fn:9] used to its full capacity

[fn:8] Sequence of states/augmentations

[fn:7] Connections are made from higher level to lower level. So
shortest path is not decreased.

[fn:6] by removing edges from a network, the distance cannot be decreased.

[fn:5] correctness proof of FF is common Exam question. 

[fn:4] In Exam sometimes: Why is it optimal what you have computed?
The answer is not that in the residual network there is no path from s
to t. 

[fn:3] |E| = m & |V| = n

[fn:2] typical exam question: Why does Ford Fulkerson terminate?

[fn:1] e_R = Reverse edge 
